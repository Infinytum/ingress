package ingress

import (
	"encoding/json"

	"github.com/caddyserver/caddy/v2"
	"github.com/caddyserver/caddy/v2/modules/caddyhttp"
	"github.com/infinytum/reactive"
	"k8s.io/apimachinery/pkg/util/errors"
)

// GlobalDiffuser is a reactive pipe that generates routes by
// executing the specified pipeline for each ingress path in each rule.
func GlobalDiffuser(pipeline reactive.Subjectable) reactive.Pipe {
	return GlobalPipe(func(ctx *GlobalContext, errs []error) []error {
		// Each Path of the Ingress warrants a separate route
		// These routes are generated by the specific pipeline
		specifics := make([]*SpecificContext, 0)
		for _, rule := range ctx.Ingress.Spec.Rules {
			for _, path := range rule.HTTP.Paths {
				intCtx := &SpecificContext{
					Context: ctx.Context,
					Path:    path,
					Route: &caddyhttp.Route{
						HandlersRaw:    []json.RawMessage{},
						MatcherSetsRaw: []caddy.ModuleMap{},
					},
					Rule: rule,
				}
				specifics = append(specifics, intCtx)
			}
		}

		// Run the specific pipeline for each path and wait for the results
		for _, specific := range specifics {
			err := await(specific, pipeline)
			if err == nil {
				ctx.Routes = append(ctx.Routes, specific.Route)
			}
		}

		return errs
	})
}

// await runs the given pipeline and waits for the result
func await(ctx *SpecificContext, pipeline reactive.Subjectable) error {
	ctxChan := make(chan error, 1)
	subscription, _ := pipeline.Subscribe(func(spfCtx *SpecificContext, errs []error) {
		if ctx != spfCtx {
			return
		}
		if len(errs) > 0 {
			ctxChan <- errors.NewAggregate(errs)
			return
		}
		ctxChan <- nil
	})
	pipeline.Next(ctx, make([]error, 0))
	err := <-ctxChan
	pipeline.Unsubscribe(subscription)
	return err
}
